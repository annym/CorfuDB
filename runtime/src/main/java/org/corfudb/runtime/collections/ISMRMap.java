package org.corfudb.runtime.collections;

import com.google.common.collect.ImmutableMap;
import org.corfudb.annotations.*;
import org.corfudb.protocols.logprotocol.SMREntry;
import org.corfudb.runtime.object.ICoalescableObject;
import org.corfudb.runtime.object.ISMREntry;
import org.corfudb.runtime.object.ISMREntryGenerator;

import java.util.*;

/**
 * Created by mwei on 1/9/16.
 */
public interface ISMRMap<K, V> extends Map<K, V>, ISMRObject, ICoalescableObject {

    /**
     * {@inheritDoc}
     *
     * Conflicts: this operation conflicts with any modification to
     * the map, since the size of the map could be potentially changed.
     */
    @Accessor
    @Override
    int size();

    /**
     * {@inheritDoc}
     *
     * Conflicts: this operation conflicts with any modification to
     * the map, since the size of the map could be potentially changed.
     */
    @Accessor
    @Override
    boolean isEmpty();

    /**
     * {@inheritDoc}
     *
     * Conflicts: this operation conflicts with any operation on the
     * given key.
     */
    @Accessor
    @Override
    boolean containsKey(@ConflictParameter Object key);

    /**
     * {@inheritDoc}
     *
     * Conflicts: this operation conflicts with any modification to
     * the map, since the presence of values could be potentially changed.
     */
    @Accessor
    @Override
    boolean containsValue(Object value);

    /**
     * {@inheritDoc}
     *
     * Conflicts: this operation conflicts with any operation on the
     * given key.
     */
    @Accessor
    @Override
    V get(@ConflictParameter Object key);

    /**
     * {@inheritDoc}
     *
     * Conflicts: this operation produces a conflict with any other
     * operation on the given key.
     */
    @MutatorAccessor(name = "put", undoFunction = "undoPut", undoRecordFunction = "undoPutRecord")
    @Override
    V put(@ConflictParameter K key, V value);


    /**
     * This operation behaves like a put operation, but does not
     * return the previous value, and does not result in a read
     * of the map.
     *
     * Calling this operation produces the same put record as calling
     * "put" directly. However, the runtime will not try to sync
     * the object to obtain an upcall.
     *
     * Conflicts: this operation produces a conflict with any other
     * operation on the given key.
     */
    @Mutator(name = "put", noUpcall = true)
    default void blindPut(@ConflictParameter K key, V value) {
        put(key, value);
    }

    /** Generate an undo record for a put, given the previous state of the map
     * and the parameters to the put call.
     *
     * @param previousState     The previous state of the map
     * @param key               The key from the put call
     * @param value             The value from the put call. This is not
     *                          needed to generate an undo record.
     * @return                  An undo record, which for a put is the
     *                          previous value in the map.
     */
    default V undoPutRecord(ISMRMap<K,V> previousState, K key, V value) {
        return previousState.get(key);
    }

    /** Undo a put, given the current state of the map, an undo record
     * and the arguments to the put command to undo.
     *
     * @param map           The state of the map after the put to undo
     * @param undoRecord    The undo record generated by undoPutRecord
     * @param key           The key of the put to undo
     * @param value         The value of the put to undo, which is not
     *                      needed.
     */
    default void undoPut(ISMRMap<K,V> map, V undoRecord, K key, V value) {
        if (undoRecord == null) {
            map.remove(key);
        }
        else {
            map.put(key, undoRecord);
        }
    }

    /**
     * {@jnheritDoc}
     *
     * Conflicts: this operation produces a conflict with any other
     * operation on the given key.
     */
    @MutatorAccessor(name="remove", undoFunction = "undoRemove", undoRecordFunction = "undoRemoveRecord")
    @Override
    V remove(@ConflictParameter Object key);

    /** Generate an undo record for a remove, given the previous state of the map
     * and the parameters to the remove call.
     *
     * @param previousState     The previous state of the map
     * @param key               The key from the remove call
     * @return                  An undo record, which for a remove is the
     *                          previous value in the map.
     */
    default V undoRemoveRecord(ISMRMap<K,V> previousState, K key) {
        return previousState.get(key);
    }

    /** Undo a remove, given the current state of the map, an undo record
     * and the arguments to the remove command to undo.
     *
     * @param map           The state of the map after the put to undo
     * @param undoRecord    The undo record generated by undoRemoveRecord
     */
    default void undoRemove(ISMRMap<K,V> map, V undoRecord, K key) {
        if (undoRecord == null) {
            map.remove(key);
        }
        else {
            map.put(key, undoRecord);
        }
    }

    /**
     * {@inheritDoc}
     *
     * Conflicts: this operation conflicts on any keys that are in the map given.
     */
    @Mutator(name="putAll", undoFunction="undoPutAll",
            undoRecordFunction="undoPutAllRecord", conflictParameterFunction="putAllConflictFunction")
    @Override
    void putAll(Map<? extends K, ? extends V> m);


    /** Generate the conflict parameters for putAll, given the arguments to the
     * putAll operation.
     * @param m                 The map for the putAll operation.
     * @return                  An array of conflict parameters, which are the
     *                          hash codes of the keys given.
     */
    default Object[] putAllConflictFunction(Map<? extends K, ? extends V> m) {
        return m.keySet().stream()
                .map(Object::hashCode)
                .toArray(Object[]::new);
    }

    enum UndoNullable {
        NULL;
    }

    /** Generate an undo record for putAll, given the previous state of the map
     * and the parameters to the putAll call.
     *
     * @param previousState     The previous state of the map
     * @param m                 The map from the putAll call
     * @return                  An undo record, which for a putAll is all the
     *                          previous entries in the map.
     */
    default Map<K,V> undoPutAllRecord(ISMRMap<K,V> previousState, Map<? extends K, ? extends V> m) {
        ImmutableMap.Builder<K,V> builder = ImmutableMap.builder();
        m.keySet().forEach(k -> builder.put(k,
                (previousState.get(k) == null ? (V) UndoNullable.NULL : previousState.get(k))));
        return builder.build();
    }

    /** Undo a remove, given the current state of the map, an undo record
     * and the arguments to the remove command to undo.
     *
     * @param map           The state of the map after the put to undo
     * @param undoRecord    The undo record generated by undoRemoveRecord
     */
    default void undoPutAll(ISMRMap<K,V> map, Map<K,V> undoRecord, Map<? extends K, ? extends V> m) {
        undoRecord.entrySet().forEach(e -> {
                    if (e.getValue() == UndoNullable.NULL) { map.remove(e.getKey()); }
                    else { map.put(e.getKey(), e.getValue()); }
                });
    }


    /**
     * {@inheritDoc}
     *
     * Conflicts: this operation conflicts with the entire map, since it drops
     * all mappings which are present.
     */
    @Mutator(name="clear", reset=true)
    @Override
    void clear();

    /**
     * {@inheritDoc}
     *
     * This function currently does not return a view like the java.util implementation,
     * and changes to the keySet will *not* be reflected in the map.
     *
     * Conflicts: This operation currently conflicts with any modification
     * to the map.
     */
    @Accessor
    @Override
    Set<K> keySet();

    /**
     * {@inheritDoc}
     *
     * This function currently does not return a view like the java.util implementation,
     * and changes to the values will *not* be reflected in the map.
     *
     * Conflicts: This operation currently conflicts with any modification
     * to the map.
     */
    @Accessor
    @Override
    Collection<V> values();

    /**
     * {@inheritDoc}
     *
     * This function currently does not return a view like the java.util implementation,
     * and changes to the entrySet will *not* be reflected in the map.
     *
     * Conflicts: This operation currently conflicts with any modification
     * to the map.
     */
    @Accessor
    @Override
    Set<Entry<K, V>> entrySet();

    @Override
    default List<ISMREntry> coalesceUpdates(List<ISMREntry> updates, ISMREntryGenerator generator) {
        // The coalesced entry can have three components: a clear call, and a list of put and remove calls.
        List<ISMREntry> putCallsToMerge = new LinkedList<>();
        List<ISMREntry> removeCallsToMerge = new LinkedList<>();

        // Iterate through all the entries, starting from the end.
        List<ISMREntry> newUpdates = new ArrayList<>();
        ListIterator<ISMREntry> updateIterator = updates.listIterator(updates.size());
        while (updateIterator.hasPrevious()) {
            ISMREntry entry = updateIterator.previous();
            // clear any undo information, since
            // it will be wrong.
            entry.clearUndoRecord();
            if (entry.getSMRMethod().equals("clear")) {
                // If this is a clear call, we can stop
                // since nothing before this call is needed
                // but we need to add the clear call itself
                // as the first record.
                newUpdates.add(0, entry);
                break;
            }
            else if (entry.getSMRMethod().equals("put")) {
                // If a remove entry doesn't already exist for this
                // put, add it to the list of put calls.
                if (!removeCallsToMerge.stream().anyMatch(x ->
                        // argument 0 is the key for "remove" and "put"
                        x.getSMRArguments()[0].equals(entry.getSMRArguments()[0]))) {
                    putCallsToMerge.add(entry);
                }
            }
            else if (entry.getSMRMethod().equals("putAll")) {
                // same as above.
                if (!removeCallsToMerge.stream().anyMatch(x ->
                        ((Map<K,V>)entry.getSMRArguments()[0]).keySet().stream()
                            .anyMatch(y ->  y.equals(x.getSMRArguments()[0])))) {
                    putCallsToMerge.add(entry);
                }
            }
            else if (entry.getSMRMethod().equals("remove")) {
                // if the remove isn't remapped by a subsequent put
                if (!putCallsToMerge.stream().anyMatch(x -> {
                    if (x.getSMRMethod().equals("put")) {
                        return x.getSMRArguments()[0].equals(entry.getSMRArguments()[0]);
                    } else if (x.getSMRMethod().equals("putAll")) {
                        return  ((Map<K,V>)x.getSMRArguments()[0]).keySet().stream()
                                .anyMatch(y ->  y.equals(entry.getSMRArguments()[0]));
                    }
                    throw new RuntimeException("Attempted to coalesce an unknown SMR map call");
                })) {
                    removeCallsToMerge.add(entry);
                }
            }
            else {
                throw new RuntimeException("Attempted to coalesce an unknown SMR map call");
            }
        }

        // Merge all the put calls by generating one large putAll call, unless there's only one entry.
        if (putCallsToMerge.size() == 1) {
            newUpdates.addAll(putCallsToMerge);
        } else if (putCallsToMerge.size() > 1) {
            Map<K,V> map = new HashMap();
            // in reverse order (which would be from the EARLIEST puts to the latest puts)
            // insert into merge map
            ListIterator<ISMREntry> iterator = putCallsToMerge.listIterator(putCallsToMerge.size());
            while (iterator.hasPrevious()) {
                ISMREntry putEntry = iterator.previous();
                if (putEntry.getSMRMethod().equals("put")) {
                    map.put((K) putEntry.getSMRArguments()[0], (V)putEntry.getSMRArguments()[1]);
                } else if (putEntry.getSMRMethod().equals("putAll")) {
                    map.putAll((Map<K,V>) putEntry.getSMRArguments()[0]);
                }
            }
            newUpdates.add(generator.generate("putAll", new Object[] {map},
                    false, null));
        }

        // And just add all the remove calls, since we don't have removeAll (yet)
        newUpdates.addAll(removeCallsToMerge);
        return newUpdates;
    }
}
